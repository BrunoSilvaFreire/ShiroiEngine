#include <utility>
#include <parser.h>
#include <glog/logging.h>
#include <iostream>
#include <string>
#include <fstream>

#define GENERATED_SOURCE_HEADER \
"/* \n\
 * This file has been generated by the ShiroiEngine. \n\
 * Modifying it is useless as it will be overwriten at some point. \n\
 */\n"

const int8 skipChars[] = {' ', '\n'};

bool isSkipCharacter(int8 c) {
    for (char sc : skipChars) {
        if (c == sc) {
            return true;
        }
    };
    return false;
}

Tokenized lex(std::string &source) {
    uint32 i = 0;
    int8 character;
    std::string currentToken;
    std::vector<Token> tokens;
    do {
        character = source[i];
        if (isSkipCharacter(character)) {
            if (!currentToken.empty()) {
                tokens.emplace_back(currentToken);
                currentToken = "";
            }
        } else {
            currentToken += character;
        }
        i++;
    } while (character != '\0');
    return Tokenized(tokens);
}

class SerializedField {
private:
    std::string fieldType;
    std::string fieldName;
public:
    SerializedField(std::string fieldType, std::string fieldName) :
            fieldType(std::move(fieldType)),
            fieldName(std::move(fieldName)) {

    }

    const std::string &getFieldType() const {
        return fieldType;
    }

    const std::string &getFieldName() const {
        return fieldName;
    }

    friend std::ostream &operator<<(std::ostream &os, const SerializedField &field) {
        os << "fieldType: " << field.fieldType << " fieldName: " << field.fieldName;
        return os;
    }
};

std::string tryTrim(std::string basic_string, char i);

std::string generateDeserializer(std::string basic_string, std::vector<SerializedField> fields);

std::string generateSerializer(std::string basic_string, std::vector<SerializedField> vector);

void generateTo(std::string &source, std::filesystem::path outputPath) {
    auto tokens = lex(source).getTokens();
    std::string generatedSource;
    std::vector<SerializedField> serializedFields;
    for (uint32 i = 0; i < tokens.size(); i++) {
        Token &token = tokens[i];
        if (token.getValue().find("SERIALIZE") == 0) {
            std::string fieldType = tokens[i + 1].getValue();
            std::vector<std::string> members;
            bool mayHaveMore = true;
            uint32 currentName = 0;
            while (mayHaveMore) {
                std::string possibleName = tokens[i + 2 + currentName].getValue();
                mayHaveMore = possibleName.find(';') == std::string::npos;
                auto pureName = possibleName;
                pureName = tryTrim(pureName, ';');
                pureName = tryTrim(pureName, ',');
                members.push_back(pureName);
                currentName++;
            }
            for (std::string member : members) {
                serializedFields.emplace_back(fieldType, member);
            }
        }
    }
    std::string className;
    for (uint32 i = 0; i < tokens.size(); i++) {
        Token &token = tokens[i];
        if (token.getValue() == "class") {
            className = tokens[i + 1].getValue();
            break;
        }
    }
    generatedSource += generateDeserializer(className, serializedFields);
    generatedSource += "\n";
    generatedSource += generateSerializer(className, serializedFields);
    LOG(INFO) << "Generated: ";
    LOG(INFO) << generatedSource;
    std::ofstream ofstream(outputPath.string());
    ofstream << GENERATED_SOURCE_HEADER;
    ofstream << "#include <serialization/serialized_object.h> \n";
    ofstream << "#define GENERATED_SOURCE() \\\n";
    for (std::string &str : split(generatedSource, '\n')) {
        ofstream << str << '\\' << std::endl;
    };
    ofstream.close();
}

#define TAB "    "

std::string generateSerializer(std::string className, std::vector<SerializedField> fields) {
    std::string serializer = "void serialize(SerializedObject& obj) {\n";
    for (SerializedField &field : fields) {
        serializer += TAB;
        serializer += "obj.write<";
        serializer += field.getFieldType();
        serializer += ">(";
        serializer += field.getFieldName();
        serializer += ");\n";
    }
    serializer += "}\n";
    return serializer;
}


std::string generateDeserializer(std::string className, std::vector<SerializedField> fields) {
    std::string deserializer = className + "(Scene * scene, SerializedObject& obj) : SceneObject(scene) {\n";
    for (SerializedField &field : fields) {
        deserializer += TAB;
        deserializer += "// ";
        deserializer += field.getFieldName();
        deserializer += " = obj.extract<";
        deserializer += field.getFieldType();
        deserializer += ">(\"";
        deserializer += field.getFieldName();
        deserializer += "\");";
        deserializer += "\n";
    }
    deserializer += "}";
    return deserializer;
}

std::string tryTrim(std::string string, char c) {
    auto fi = string.find_last_of(c);
    if (fi != std::string::npos) {
        return string.substr(0, fi);
    }
    return string;
}
